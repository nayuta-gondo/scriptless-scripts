Adaptor Signatures and Atomic Swaps from Scriptless Scripts
===========================

This document describes adaptor signatures and multisignatures, which are the
original building blocks of scriptless scripts. It also describes an atomic
swap protocol using these building blocks.

このドキュメントでは、スクリプトレススクリプトの元のビルディングブロックであるアダプタ署名とマルチシグネチャについて説明します。
また、これらのビルディングブロックを使用するアトミックスワッププロトコルについても説明します。

### Motivation

On a high level the scheme works as follows. Suppose A is trying to send coins
to B on one chain, while B is sending coins to A on the other.

上位レベルでは、このスキームは以下のように動作します。
Aが一方のチェーンでBにコインを送ろうとしていて、
Bが他方のチェーンでコインをAに送ろうとしています。

1. Both parties A and B put their coins into multisignature outputs on each chain
   which require both parties' signatures to be spent.
2. A gives B auxiallary data "adaptor signatures" which allow A to extract a
   discrete logarithm from a signature on one chain, and conversely to extract a
   signature from the same discrete logarithm on the other chain.
3. B then signs to give A her coins on one chain.
4. When A signs to take her coins, B is able to extract a discrete logarithm
   from her signature.
5. He uses this to form a signature on the other chain, giving him A's coins.

（XXX: 区切り）

1. 両当事者AとBは、それぞれのチェーンのマルチシグネチャ出力にコインを入れます。
これらを使用するには、両当事者の署名が必要です。
2. AはBにアダプタ署名という補助的なデータを渡します。
これはAが、あるチェーン上の署名から離散対数を抽出し、
反対に他のチェーン上で同じ離散対数による署名を抽出することを可能にします。
（XXX: 英語がよくわからないが、実際に抽出するのはBじゃなかろうか？）
3. Bはそのとき、一方のチェーン上で彼女にコインに与えるための署名を行います。
4. Aが彼女のコインを受け取るために署名するとき、Bは彼女の署名から離散対数を抽出できます。
5. 彼はこれを使って他方のチェーンで署名を作成し、それは彼にAのコインを与えます。

We see that this executes an atomic exchange: if A signs, then both transactions
execute; if A does not sign, then the protocol times out and neither transaction
executes.

これによりアトミックな交換が実行されることがわかります。
Aが署名すれば、両方のトランザクションが実行されます。
Aが署名しなければ、プロトコルはタイムアウトし、どちらのトランザクションも実行されません。

However, if each chain requires signatures which use different curves, it is
impossible to use the same discrete logarithm in steps 4 and 5. To see this,
we need to look at the adaptor signature protocol in more detail.

ただし、各チェーンに異なる曲線を使用する署名が必要な場合は、手順4と5で同じ離散対数を使用することはできません。
これを確認するには、アダプタ署名のプロトコルをさらに詳しく調べる必要があります。

#### Adaptor Signatures

Consider a fixed prime-order group generated by a fixed generator `G`. Let `H`
be a hash function mapping from the space of bitstrings to the scalar group (of
integers modulo the order of `G`). Then a _Schnorr signature_ on a message `m`
with public key `P` is a pair `(s, R)` satisfying the equation

定点のジェネレータGによって生成された固定の素数位数の群を考えてみましょう。
Hを、ビット列の空間を（Gの位数を法とする整数の）スカラグループに写像するハッシュ関数としましょう。
そのとき、公開鍵Pを用いたメッセージmのシェノア署名はその方程式を満たす(s, R)のペアです。

```
sG = R + H(P || R || m)P
```
Closely related, an _adaptor signature_ is a triplet `(s', R, T)` satisfying

密接に関連しているアダプタ署名は、以下を満たすトリプレット(s', R, T)です。

```
s'G = T + R + H(P || R || m)P
```
It is easy to see that given a Schnorr signature `(s, R)` and adaptor signature
`(s', R, T)` (notice both `R`s are the same) that the discrete logarithm of `T`
can be computed as `s' - s`, since subtracting the above equations reveals
`(s' - s)G = T`.

シェノア署名(s, R)とアダプタ署名 (s', R, T)（両方のRが同じであることに注意してください）が与えられると、
上記の方程式の引き算が(s' - s)G = Tを明らかにするため、
Tの離散対数がs' - sとして計算できることを確認するのは容易です。

Similarly, given an adaptor signature `(s', R, T)` and `t` such that `T = tG`,
it is easy to compute a Schnorr signature `(s, R)` by the equation `s = s' - t`.

同様に、アダプタ署名(s', R, T)とT = tGであるようなtが与えられると、
方程式s = s' - tで
シュノア署名(s, R)を計算するのは容易です。

We conclude that given an adaptor signature `(s', R, T)` with public key `P`,
knowledge of a Schnorr signature with same `P` and same `R` is equivalent to
knowledge of the discrete logarithm of `T`.

公開鍵Pを用いたアダプタ署名(s', R, T)が与えられると、
同じPとRを用いたシェノア署名の知識は、
Tの離散対数の知識と等価であると結論付けます。

#### Schnorr Multisignatures

It is possible for two parties with public keys `P` and `Q` to interactively
create a multisignature on key `P` and `Q`. The components `(s, R)` of the
signature are each the sum of both parties' contributions. Importantly, in
the first step of the interaction the two parties agree on `R`, and in the
second step each party reveals their contribution to `s`.

公開鍵PとQを持つ2人の当事者は、鍵PとQを用いたマルチシグネチャを対話的に作ることが可能です。
署名(s, R)の構成要素は、それぞれが両当事者の関与の合計です。
重要なことは、相互作用の最初のステップで2人の当事者がRに同意し、
2番目のステップでは各当事者が彼らのsへの関与を明らかにします。

#### Atomic Swaps Using Adaptor Signatures

On a lower level, the above scheme works as follows. We assume first that both
blockchains use the same group generated by the same fixed generator `G`, and
that both blockchains support Schnorr signatures.

下位レベルでは、上記のスキームは次のように動作します。
両方のブロックチェーンが同じ定点のジェネレータGによって生成された同じ群を使用し、
両方のブロックチェーンがシュノア署名をサポートすると最初に仮定します。

1. Each party puts their coins into a multisignature output. They agree on an
   `R` for each signature that they'll eventually use to move the coins to their
   final destinations.
2. A chooses a random `t`, sets `T = tG`, and produces adaptor signatures in place
   of her contributions to `s`. Each signature uses the same `T`. She sends these
   to B.
3. B reveals his contribution to `s` for the signature that sends his coins to A.
4. A reveals her contribution to `s` for that signature, completing it, and
   publishes it to take her coins.
5. Using the adaptor signature, B learns `t` from the output of step (4), and uses
   it to compute A's contribution to `s` for the signature that sends her coins to
   him.
6. B adds his contribution to `s`, completing the signature, and publishes it to
   take his coins.

（XXX: 区切り）

1. 各当事者は、コインをマルチシグネチャ出力に入れます。
彼らは各署名のためのRに同意します。各署名は結局は、コインをそれらの最終的な目的地に移動するために使用されます。
2. Aは乱数tを選択し、T = tGを設定し、彼女のsへの関与の代わりであるアダプタ署名を生成します。
各署名は同じTを使用します。
彼女はこれらをBに送ります。
3. Bは彼のコインをAに送る署名sのための彼の関与を明らかにします。
4. Aはその署名sのための彼女の関与を明らかにし、それを完成させ、コインを取るために公開します。
5. アダプタ署名を使用して、Bはステップ（4）の出力からtを学習し、コインを彼に送る署名sに対するAの関与を計算するために使用します。
6. Bは彼の関与をsに追加し、署名を完成させ、彼のコインを受け取るためにそれを公開します。

XXX: 以下コメント

若干表記が省略されているわかりづらいので以下のようにする。
どちらのチェーンのものか、だれが関与しているか明確にした。

* ジェネレータ: G1, G2
* 署名対象: m1, m2
* 秘密鍵: x1a, x1b, x2a, x2b
* 公開鍵: P1a, P1b, P2a, P2b
* シェノア署名の乱数: k1a, k1b, k2a, k2b
* シェノア署名の乱数の点: R1a, R1b, R2b, R2b
* シェノア署名: s1a, s1b, s2a, s2b

以下、それぞれを集約（加算）したもの

* 秘密鍵: x1, x2
* 公開鍵: P1, P2
* シェノア署名の乱数: k1, k2
* シェノア署名の乱数の点: R1, R2
* シェノア署名: s1, s2

アダプタ署名は追加の乱数がチェーン共通、Aのみが生成

* アダプタ署名の乱数: ta
* アダプタ署名の乱数の点: Ta
* アダプタ署名: s'1a, s'2a

この上で、最後のシーケンスを書き直してみる。

1. 各当事者は、コインをマルチシグネチャ出力に入れます（それぞれx1, x2でロック）。
彼らは各署名のためのR1、R2に同意します。各署名（s1、s2でそれぞれアンロックできる）は結局は、
コインをそれらの最終的な目的地に移動するために使用されます。
2. Aは乱数taを選択し、Ta = taGを設定し、
彼女のs1、s2への関与s1a、s2aの代わりであるアダプタ署名s'1a、s'2aを生成します。
各署名は同じTaを使用します。
彼女はこれらをBに送ります。
3. Bは彼のコインをAに送る署名s1のための彼の関与s1bを明らかにします。
4. Aはその署名s1のための彼女の関与s1aを明らかにし、それを完成させ、コインを取るために公開します。
5. アダプタ署名s'1aを使用して、Bはステップ（4）の出力からtaを学習し、コインを彼に送る署名s2に対するAの関与s2aを計算するために使用します。
6. Bは彼の関与s2bをs2に追加し、署名を完成させ、彼のコインを受け取るためにそれを公開します。

```
// 1
R1a = k1aG, R1b = k1bG, R1 = R1a + R1b
R2a = k2aG, R2b = k2bG, R2 = R2a + R2b

// 2
Ta = taG
s'1a = ta + k1a + H(P1 || R1 || m1)x1a
s'2a = ta + k2a + H(P2 || R2 || m2)x2a

// 3
s1b = k1b + H(P1 || R1 || m1)x1b

// 4
s1a = k1a + H(P1 || R1 || m1)x1a
s1 = s1a + s1b

// 5
s1a = s1 - s1b
ta = s'1a - s1a
s2a = s'2a - ta

// 6
s2 = s2a + s2b
```
